# 1. 데이터 시각화

## 1) 관련 용어

- 피쳐 
  - 데이터의 특성이나 특징
- 데이터 테이블 
  - 데이터를 표로 표현한 것
- 데이터 인스턴스
  - 하나의 데이터
  - 튜플이라고도 부름
  - 예시 : 엑셀에서 한 행

## 2) 데이터의 분류

1. 연속형 데이터
   - 연속된 아날로그 데이터, 실수 데이터
2. 이산형 데이터
   - 분리해서 표현하는 이진 데이터, 디지털 데이터, 라벨로 구분

**연속형 데이터는 범위(scale)이 존재하나 이산형 데이터는 존재하지 않는다**

- 이산형 데이터 분류
  - 숫자형 데이터 : 연속형 데이터, 정략적으로 측정 가능
  - 명목형 데이터 : 카테고리로 분류 가능
  - 서수형 데이터 : 범주형 데이터, 데이터 간의 순서가 존재

### * 데이터의 형식

- 테이블 형태
  - csv(comma separate value)
  - xlsx(엑셀)
- 트리 형태
  - json
  - xml
- 파이썬 특화
  - pickle
- 큰 데이터(이진 데이터 형식)
  - h5



# 2. Numpy

## 1) 정의

- 리스트와 리스트 간의 연산이 가능하도록 해주는 라이브러리
- python의 고성능 과학 계산용 라이브러리
- 선형대수의 표현법을 코드로 처리
- 다차원이나 크기가 큰 데이터 처리에 유리

## 2) 특징

- 정적 할당의 구성 방식을 가진다
- 행렬 연산 특화
- 속도가 빠르고 메모리를 효율적으로 사용
- 반복문을 사용하지 않음
- 병렬 연산
- C,C++,포트란 언어와 통합이 가능
- !!단, 리스트 간의 연결 연산은 일반적인 리스트에 비해 느리다

## 3) 용어

- Numpy 배열 
  - Numpy에서 텐서 데이터를 다루는 객체
- 텐서(tensor)
  - 선형대수의 데이터 배열

## 4) 각종 기능

- 모듈 import

  ``import numpy as np``

- 배열 생성

  ``test_array=np.array({리스트구조},{자료형})``

  - 배열의 원소는 반드시 리스트 형식

  - 데이터 타입은 np.float32 등 제공되는 타입을 사용하는 것 추천

  - 배열의 모든 구성 요소에 값이 존재해야 한다

    ex) [[1,4,5,7],[1,4,2]] 는 배열의 원소가 맞지 않는다

- 데이터 특징 출력

  ``test_array.dtype``

  - Numpy 배열의 데이터 타입 반환

  ``test_array.shape``

  - Numpy 배열에서 객체의 차원 구성 정보 반환

  ``test_array.ndim``

  - 최대 차원 반환

  ``test_array.size``

  - 원소 개수 반환

- 데이터 타입 지정

  ``test_array=np.array([1,2,3,4],dtype=np.float64)``

  - 배열의 데이터 타입을 64비트 float형으로 지정
  - 타입을 지정하지 않으면 데이터의 요소에 따라 자동 부여된다

- 데이터 구조 변경

  ``test_array.reshape({차원1의크기},{차원2의크기},...)``

  - 지정한 차원의 크기로 구조를 변형한다
  - -1로 지정하면 나머지 차원의 크기를 지정했을 때 전체 요소의 개수를 고려하여 마지막 차원이 자동으로 지정된다
  - **단, 전체 요소의 개수는 통일되어야한다**

  ``test_array.T`` : 가로와 세로를 바꾼다.

  ``test_array.flatten()``

  - 데이터 그대로 1차원으로 변경한다

- 인덱싱 방법

  - Numpy는 인덱싱 표현에 ','를 이용한다
  - '[행]\[열]'의 형태는 '[행,열]'의 형태와 동일하게 취급된다

- 슬라이싱

  - ``test_array[:2,:]``

    행을 0~1까지 열은 모두의 형태로 반환

    즉, 각 랭크(차원)의 요소별로 모두 적용할 수 있다 

- range의 값을 담아서 배열 생성

  - ``test_array=np.arange(10)``

    0~9까지의 원소를 담은 numpy 배열 생성

### (1) Numpy 함수

- ones 함수

  - 1로만 구성된 numpy 배열을 생성

  - shape와 연계하여 사용가능

  - ``test_array=np.ones(shape=(2,2,10))``

    '1'로 채워진 2X2X10의 배열을 생성한다

- zeros 함수

  - 사용은 ones와 같으며 0으로만 구성된 numpy 배열을 생성한다

- empty 함수

  - 활용 가능한 메모리 공간을 확보하여 반환한다

- full 함수

  - 원하는 구조에 원하는 값으로 채워 넣음

  - ``np.full((2,2),10)``

    2X2의 10으로 채워진 배열

*** 마찬가지로 생성시 dtype 옵션을 부여하면 해당 데이터 타입으로 생성할 수 있다***

- ones_like 함수

  - 기존의 numpy 배열과 같은 크기로 만들어 내용을 1로 채움
  - ``np.ones_like({numpy배열객체})``

- zeros_like 함수

  - 기존의 numpy 배열과 같은 크기로 만들어 내용을 0으로 채움
  - ``np.zeros_like({numpy배열객체})``

- empty_like 함수

  - 기존의 numpy 배열과 같은 크기로 만들어 빈 상태로 만듦
  - ``np.empty_like({numpy배열객체})``

- identity 함수

  - 단위 행렬 생성

  - ``np.identity(n)``

    nxn의 단위행렬을 생성한다

- eye 함수

  - 시작점과 행렬 크기를 지정한 단위행렬 생성
  - N : 행의 개수, M : 열의 개수, k : 열의 값 기준 시작 인덱스
  - ``np.eye(N=3,M=5,k=1)``

- diag 함수

  - 행렬의 대각성분 값 추출

  - ``np.diag({numpy배열객체},k=1)``

    k : 대각성분의 시작점

- uniform 함수

  - 균등분포 함수
  - ``np.random.uniform(시작값,끝값,데이터개수)``

- normal 함수

  - 정규분포 함수
  - ``np.random.normal(평균값,분산,데이터개수)``

- 연산 함수

  ```python
  # axis(축) : 0부터 고차원에서 저차원의 축을 가리킨다
  # !! axis를 지정하지 않으면 전체 값에 대한 연산이 이루어진다
  # sum
  # n차원의 축으로 서로 합계산
  test_array.sum(axis=n) 
  
  # mean 
  # n차원의 축을 기준으로 평균 연산
  test_array.mean(axis=n)
  
  # str
  # n차원의 축을 기준으로 평균 연산
  test_array.str(axis=n)
  
  # sqrt
  # 각 요소에 제곱근 연산 수행
  np.sqrt(test_array)
  ```

  

- 연결 함수

  - vstack
    - 배열을 수직으로 붙여 하나의 행렬 생성
    - ``np.vstack((배열1,배열2))``
  - hstack
    - 배열을 수평으로 붙여 하나의 행렬 생성
    - **python은 1차원 배열의 열 형태를 지원하지 않으므로 ``reshape(-1,1)``을 통해서 생성한다**
    - ``np.hstack((배열1,배열2))``
  - concatenate
    - 두 객체 간의 결합
    - 다차원의 결합이 있을 때 사용한다
    - ``np.concatenate((배열1,배열2),axis=n)``

- 사칙연산

  - numpy 배열은 배열끼리의 사칙연산을 모두 지원한다
  - 계산은 각 요소끼리의 계산으로 이루어진다

  ```python
  np_ar_1+np_ar_1
  np_ar_1-np_ar_1
  np_ar_1*np_ar_1
  np_ar_1/np_ar_1
  np_ar_1%np_ar_1
  # 등등
  ```

- 내적(dot 함수)

  - 두 배열간의 곱셈

  - 주의점

    - 두 개의 행렬에서 첫 번째 행렬의 열 크기와 두 번째 행려의 행 크기가 동일해야 함

  - 코드

    ```python
    x=np.arange(1,7).reshape(m,n)
    y=np.arange(1,7).reshape(n,k)
    np.dot(x,y) # 두 행렬을 내적한다
    x.dot(y) # 위의 식과 같은 의미
    ```

- 브로드캐스팅 연산

  - 하나의 행렬과 스칼라 값들 간의 연산, 행렬과 벡터간의 연산

  - 예시

    ```python
    x=np.arange(1,13).reshape(4,3)
    v=np.array([10,20,30])
    print(x+v)
    
    '''
    결과:
    array([[11, 22, 33],
           [14, 25, 36],
           [17, 28, 39],
           [20, 31, 42]])
    '''
    ```

- 비교연산

  - 브로드캐스팅 비교연산

    ```python
    x=np.arange(1,13).reshape(4,3)
    print((x>5))
    
    '''
    결과:
    array([False, False, False,  True,  True,  True,  True])
    '''
    ```

    전체 요소에 대한 비교로 적용된다

    + (n차원,n-1차원,...) 처럼 차원의 요소를 지정하여 요소별 비교연산이 가능하다

  - all 함수

    - 배열 내부의 모든 값이 참일 때 True 반환

    - and 조건을 전체 요소에 적용

      ```python
      x=np.arange(1,13).reshape(4,3)
      print((x>5).all())
      
      '''
      결과:
      False
      '''
      ```

  - any 함수

    - 배열 내부의 값 중 하나라도 참일 때는  True

    - or 조건을 전체 요소에 적용

      ```python
      x=np.arange(1,13).reshape(4,3)
      print((x>5).any())
      
      '''
      결과:
      True
      '''
      ```

- where 함수

  - 배열인 불린형으로 이루어졌을때 참인 값들의 인덱스를 반환

  ```python
  x=np.array([1,2,3,4,5,1])
  # x==1 인 요소는 10으로 아니면 20으로 반환
  np.where(x==1,'10','20')
  
  '''
  결과:
  array(['10', '20', '20', '20', '20', '10'], dtype='<U2')
  '''
  ```

- argsort 함수

  - 배열 내 값들의 작은 순서대로 인덱스 반환

    ``test_array.argsort()``

- argmax 함수

  - 배열 내 값들 중 가장 큰 값의 인덱스를 반환

    ``test_array.argmax()``

- argmin 함수

  - 배열 내 값들 중 가장 작은 값의 인덱스를 반환

    ``test_array.argmin()``

### (2) numpy 인덱스

- 불린 인덱스

  - 배열에 있는 값들을 반환할 특정 조건을 불린형의 배열에 넣어서 추출

  - 인덱스에 들어가는 배열은 불린형이어야 함

  - 불린형 배열과 추출 대상이 되는 배열의 구조가 같아야 함

    ```python
    d=np.array([1,5,3,7,2,8,4])
    
    d[d>=5] # 조건을 만족하는 원소만 꺼내올 수 있다.
    
    '''
    결과:
    array([5, 7, 8])
    '''
    x=np.arange(1,11)
    l=np.array([0,5,9,0,0,0])
    # 해당 인덱스와 일치하는 원소를 꺼내온다.
    x[l]
    
    '''
    결과:
    array([ 1,  6, 10,  1,  1,  1])
    '''
    
    ```

- 팬시 인덱스

  - 정수형 배열의 값을 사용하여 해당 정수의 인덱스에 위치한 값을 반환

  - 인덱스 항목에 넣을 배열은 정수로만 구성

  - 정수 값의 범위는 대상이 되는 배열이 가지는 인덱스의 범위 내 대상이 되는 배열과 인덱스 배열의 구조가 같을 필요는 없다.

    ```python
    x=np.arange(1,11)
    x=x.reshape(2,-1)
    ''' 배열 x의 상태
    [[ 1  2  3  4  5]
     [ 6  7  8  9 10]]
    '''
    i_1=np.array([0,1])
    i_0=np.array([0,1])
    # 2차원의 0번째 1차원의 0번째 원소와
    # 2차원의 1번째 1차원의 1번째 원소를 가져온다
    x[i_0,i_1]
    
    '''
    결과 :
    array([1, 7])
    '''
    ```

    